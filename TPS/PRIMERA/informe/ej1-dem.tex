Como dentro de todas las posibles soluciones que podría encontrar un algoritmo de fuerza bruta, existen varias que no son válidas, al aplicar las podas descriptas anteriormente nos podremos quedar con todas aquellas que tienen sentido dentro de nuestro problema:


\subsubsection*{Combinaciones posibles}
En cada viaje a travez del puente, a priori se puede mandar cualquier persona, o combinación de 2 personas. Para enumerar estos casos u opciones, podemos plantear una matriz de $N \times N$ para simbolizar en cada casilla cada combinación posible. Es inmediato ver que las casillas de un lado y otro de la diagonal de la matriz repiten casos y otras en la diagonal de la misma, que repite la persona. Como también existe la posibilidad de enviar de a 1 persona por vez, entonces la diagonal de la matriz representará estas elecciones, por otro lado, nos quedaremos con solo 1 mitad de la matriz para no tener en cuenta los casos repetidos. Bajo esta representación obtenemos todas las combinaciones validas de personas que pueden llegar a viajar en cada cruce.

Como las personas solo pueden encontrarse en 1 isla en todo momento, entonces de todas las opciones se consideran aquellas que posean a todos los integrantes en el lado de partida.

\subsubsection*{Desbalance}
No puede haber más caníbales que arqueologos en ning\'un lado en ningún momento, la Elección tomada deberá mantener este invariante al enviar para el otro lado las personas elegidas.

\subsubsection*{Ciclos}
En el caso en que se envíe la opcion $(i; j)$ al lado A, bajo las restricciones anteriores nada impide que en el paso siguiente se decida mandar de regreso al mismo par, generandonos un ciclo. Esta elección claramente carece de sentido ya que nos regresa a un estado previo y con más tiempo acumulado. Podemos generalizar el ejemplo anterior a decir que no tiene sentido, dentro de una rama de solución, repetir un estado previo. Para evitarlo se debe guardar los estados previos por los cuales se pasó y desestimar cualquier opción que nos retorne a ellos.

\subsubsection*{Tiempo}
De haber encontrado una solución, no tendrá sentido, al estar buscando una nueva, seguir por una rama si se supera el tiempo de la misma, ya que de alcanzar una solución, la misma no será optima. Con lo cual, se desestima la busqueda por una rama si la misma supera en tiempo alguna solución ya encontrada. De esta forma, al finalizar el algoritmo y haber encontrado solución, podemos recuperar el tiempo logrado por la solución más rápida. Esta poda ahorra la necesidad de una vez finalizado el algoritmo, tener que hallar la soluci\'on de menor tiempo, dentro de todas las soluciones válidas encontradas.

